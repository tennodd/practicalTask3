Цей проєкт демонструє використання паралельних обчислень на прикладі двох завдань:

**1.Множення двох матриць з використанням потоків і фреймворку Fork/Join.**

Створено дві версії програми:

**Work Stealing:** Задіяно Fork/Join Framework, який автоматично виконує балансування задач за допомогою “крадіжки роботи”. Це означає, що коли один потік простоює, він може “вкрасти” підзадачу з черги зайнятого потоку. Цей підхід добре підходить для нерівномірно розподілених задач. Якщо деякі частини роботи виконуються довше, інші потоки можуть “підхопити” підзадачі, не даючи ресурсам простоювати. У випадку множення матриць з великими розмірами або файлів у дуже глибоких і розгалужених директоріях це може дати помітний виграш у продуктивності.

**Work Dealing:** Застосовано підхід з розподілом задач між потоками наперед, використовуючи ExecutorService та ThreadPool. Тут задачі “роздаються” потокам, і кожен потік виконує свою частину роботи.Коли задача більш-менш рівномірна і добре ділиться на однакові шматки, попередня роздача задач потокам може бути простішою й достатньо швидкою. При множенні матриць, де всі рядки обробляються приблизно однаково, це може спрацювати не гірше, ніж Work Stealing.

Під час запуску користувача просять ввести розміри матриць і діапазон значень для випадкової ініціалізації елементів. Обидві версії програми виводять згенеровані матриці, результат множення та час виконання.

Користувач може порівняти час виконання обох підходів і зробити висновок, яка стратегія працює краще для певних параметрів. Практичне порівняння підходів у даній задачі не виявило конкретної різниці у часі виконання між двома версіями, адже для того, щоб побачити переваги кожного з них, потрібні набагато більші об'єми задач.

**2.Пошук файлів у директорії за вказаним критерієм (буквою або словом у назві файлу).**

Програма рекурсивно проходить по директоріях, шукаючи файли, які у назві містять заданий користувачем пошуковий термін.
У даній задачі використовується підхід Work Stealing (Fork/Join). Цей вибір виправдано тим, що структура даних у файловій системі неоднорідна, тому є потреба у балансуванні нагрузки потоків в цілях оптимізації часу виконання.
